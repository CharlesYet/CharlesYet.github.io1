{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/link.yml","hash":"2dc187f8fd40f290b2d97896a95d8020bf821616","modified":1642695232232},{"_id":"source/_posts/jvm-note-1.md","hash":"dc3a451b734d727799fd03b49c307b90a9852bc1","modified":1642695232232},{"_id":"source/_posts/spring-ioc-1.md","hash":"0c46a8adccd7aa4be317b7a215d38df862ad125a","modified":1642695232232},{"_id":"source/categories/index.md","hash":"33090a4ab180ac079b241fc83d68273ac3a1df86","modified":1642695232232},{"_id":"source/link/index.md","hash":"28400454682d7a724aa9871548f4adc491af5527","modified":1642695232232},{"_id":"source/tags/index.md","hash":"788280a44179e64c8fe0088a52c7b4603abeb1e4","modified":1642695232232},{"_id":"themes/butterfly/README.md","hash":"6ee27baf95a5741abbc224ef8938d679b6597665","modified":1642695232792},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1642695232792},{"_id":"themes/butterfly/README_CN.md","hash":"49ace5208f98783344f17a00adab7641cda43280","modified":1642695232792},{"_id":"themes/butterfly/package.json","hash":"bed90f39a3bcf23dcfeb0893a366de0a2fab4ab3","modified":1642695232796},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1642695232792},{"_id":"themes/butterfly/languages/default.yml","hash":"1177f2177945c3e2447c6c0208e6ffdf0c0b186c","modified":1642695232792},{"_id":"themes/butterfly/languages/en.yml","hash":"7fe7528ed2778fe39444df2bc7e64f09e1302e97","modified":1642695232792},{"_id":"themes/butterfly/_config.yml","hash":"1cdf73c29c959172d2c1df88a4fe420d24db9cb9","modified":1642695232792},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"b1ba98565fe2d28e956225cf9e8a21f329ee060e","modified":1642695232792},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"38b32ab2aa3e2ebb9ef3c993c8dca42f1e000cd5","modified":1642695232792},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1642695232792},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1642695232792},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1642695232796},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1642695232796},{"_id":"themes/butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1642695232796},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1642695232796},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1642695232792},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1642695232792},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1642695232792},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"ab3bdeb6e0acd3d58091698c1335afb069eea7e5","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"5945f6f7f963b3ed1cc50e7e7d2e4929e1c1440c","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"428758c2459fd31efaf816c39693edb4f716b861","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"f093ab771257a6a939b194f68607a2038c8d7da3","modified":1642695232792},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1642695232796},{"_id":"themes/butterfly/scripts/events/init.js","hash":"a7f567b3d3110afe2f99c967b8e15351a7f5bd6d","modified":1642695232796},{"_id":"themes/butterfly/scripts/events/config.js","hash":"0ace90c45322ae386a3f974ab74c92e8d0dd0ab2","modified":1642695232796},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1642695232796},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1642695232796},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1642695232796},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"21379ed2dccb69c43b893895c9d56238c11e5f43","modified":1642695232796},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1642695232796},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1642695232796},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"6a103a2472903289bdecd5240eb89cac0b9e13d9","modified":1642695232796},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1642695232796},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"21556f9cb412ddc500ad12ecfd419f3ea6c9f663","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"f79c99f6c5b626c272dc2bed2b0250d6b91bb28a","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"a091f82d8897adb2347c228e544e29363c679d1f","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1642695232796},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1642695232796},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1642695232796},{"_id":"themes/butterfly/source/css/var.styl","hash":"4890a40366d6443f8b8942a4e9a6dce9fe3494f5","modified":1642695232796},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1642695232796},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1642695232796},{"_id":"themes/butterfly/source/js/main.js","hash":"1254dca2c02b3389ec0434cdd2728fdea4ae0216","modified":1642695232796},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1642695232800},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1642695232792},{"_id":"themes/butterfly/source/js/utils.js","hash":"3ee4bd9071dc6e854ffa33964f3a8da2ee2a8409","modified":1642695232800},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"9e58c80af8bbd0c66ccb4f94d3781818cebf0d66","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"65a23b5170204e55b813ce13a79d799b66b7382c","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"78a3abd90bb3c18cd773d3d5abac3541e7f415e5","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"dc3913c1a6dd207051c3d3414a33851ae8bc0a45","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"b9ebb02af8ccf43e3f73be43db19254fa913c57b","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"fed069baa9b383f57db32bb631115071d29bdc60","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"d4072f9ab79f4ac49aa251ae470abc45a2fddbd6","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"b63fd8ec48d782f51ee11226753fed1998bbf34a","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"0380a1e048e6219ea4b4a8a4eadba960edf308f0","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1642695232796},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"d9bbe20a4029e542fee9f1e1013d28d767605ffc","modified":1642695232796},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"714f19e7d66df84938bd1b82b33d5667abe1f147","modified":1642695232796},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"facf3bec0afce3bc6d077cf1939818efc7fe3bf1","modified":1642695232796},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"085e61a75588e86a6bdba75da7803411485c7b5a","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"26be2afa9d4e7016cf3c42a6cd166f01e8e4ad5c","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"d97c1722ce0fcc319f1f90ec2d51f9d746748e2b","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"193a05ab27aa5ea0fbbe0066f841cbd540db6517","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bd88ee30ebf8ca2e7b4d3a034c317fd61733921f","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"1bcbc80dff19cd53d0b367c3b9a3c751d3a1f10d","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"66c8c94bdc62e00e1dd848582aa2612ae22c1066","modified":1642695232796},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"1bfe7554c3aa8ccc6fcba5e027086188ca0a7ad7","modified":1642695232796},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"69f8e9414526dfda3af9a71c8e528fdd0ecbbfe5","modified":1642695232796},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1642695232796},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6f4b4ede52305bce9b22c8c897dcbde8af6e2ce4","modified":1642695232796},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1642695232796},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1642695232796},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"91dfd28d7e5f2113e27c8ae854337d316ca1c48f","modified":1642695232796},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"826dae759062d8f84eb2bf5ab8fdb80e0f79d58b","modified":1642695232796},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1642695232796},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"656f9007d94cf29a20532705d94fb7f22827e6fe","modified":1642695232796},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0290605c4984882990059eefe3ad18d2ac6a19ef","modified":1642695232796},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"e4c987c0202162b50dec91e1df74665d0fa933c9","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"a310e48f826a4cacc55d8e68f43806e5085554f6","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"bb2a9b7937818ff3a154c8c1009f13b534e77ec3","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"08493b66b9f31f2bd3e9a3115017a0ce16142b20","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1642695232796},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1642695232796},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1642695232796},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"aaa5e44125dcf321866bc2355a73773b11db8c9c","modified":1642695232796},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"72911c7b42e0174a979c09ead3f42ee24136feae","modified":1642695232796},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"143236e395c18d80ab8dc794821eb337c85f6b32","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"6852d4fa5fff3fe52fdc41875a2c7af57f286b3a","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"0764709381fa29778f6390d645ed137d2f91228f","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"9c96e6e67931977268b218b99084b98597c2e42b","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"e4850f2c9ba5f6b2248808f7257662679e0fab0a","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"9302837f1e35f153323bb4f166514c7e96e8ecdd","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"c271cacbac14ed665bbf47aa9c6e74e94c69dcef","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"c1c75abe5c899618ed6699c97ac999544840098a","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"59c22ebf3aaee90152e7cdb17ff5841c888fcd82","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"7648e4cb0b224f480b5f1356d64f62c9235f6723","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"0a7587a0211011b5942edba2aa80d51169561d30","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"ac811c1d6e0bf08aeb933ade1b9557e0c560d0c9","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"9028efac78e4122acd734edd5ef9110ef3f05cd1","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"5e32d903903c76db55a625640f9417d15a3a312f","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"c92df4f9d0611cf44c1a4491e226f242ec80f5bb","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"8ce336a4c8cae81b58ee26ff51040ca650ff1519","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1642695232792},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1642695232792},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1642695232796},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1642695232796},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1642695232796},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1642695232796},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"4825b1751ae46ca005b2af9d6e0a3e477c82b1f9","modified":1642695232796},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ef21990de28bd75dcd0f88b8d616e1a7a137502f","modified":1642695232796},{"_id":"public/categories/index.html","hash":"3df5159ed72bf6ef099b5849a2e93b35bb07cd46","modified":1642695363880},{"_id":"public/tags/index.html","hash":"adf845d8b1c0bcbc09be4f83c9f11d61f0995b9d","modified":1642695363880},{"_id":"public/link/index.html","hash":"03d48ae004fec078e5f626abb9339227051391a7","modified":1642695363880},{"_id":"public/2020/03/02/ckyn6c72k0001gtno1ity3u0y/index.html","hash":"de0621bc0180977a0d4d494a8c5dc0966eb92c0c","modified":1642695249654},{"_id":"public/2020/03/01/ckyn6c73e000cgtno86cr7nmw/index.html","hash":"b6c3d6b62019b1f50b5a64c4cb717755787c41af","modified":1642695249654},{"_id":"public/archives/index.html","hash":"38a4b9b7c641905b182b2ec5adbbd53dc3bfdec6","modified":1642695363880},{"_id":"public/archives/2020/index.html","hash":"cf5876827c49f3fb6756caec941b93d97bb61152","modified":1642695363880},{"_id":"public/archives/2020/03/index.html","hash":"40844560596190203490d98a261cc643af5750e6","modified":1642695363880},{"_id":"public/categories/Java/index.html","hash":"a2f8303e809509a2cb2e29979c817bfdac33cace","modified":1642695363880},{"_id":"public/index.html","hash":"49af9689104c607f69a4cd4eccd5aef481f77e91","modified":1642695363880},{"_id":"public/tags/spring/index.html","hash":"cb0c529bee10b4d66736155a545dabf01b511598","modified":1642695363880},{"_id":"public/tags/ioc/index.html","hash":"cd5b74f53fb863605cc59ee270884d74363b3597","modified":1642695363880},{"_id":"public/tags/aop/index.html","hash":"64b2151ffe3ddf35002cacad9b3dde763a483d6f","modified":1642695363880},{"_id":"public/tags/JVM/index.html","hash":"67e6d0ae0e6ab5865acbf8bba1b5d4be2544ffc0","modified":1642695363880},{"_id":"public/tags/内存模型/index.html","hash":"7e03c0c6affb9180d19aceccb195e9de0f931c9e","modified":1642695363880},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1642695249654},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1642695249654},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1642695249654},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1642695249654},{"_id":"public/js/utils.js","hash":"3ee4bd9071dc6e854ffa33964f3a8da2ee2a8409","modified":1642695249654},{"_id":"public/js/search/algolia.js","hash":"aaa5e44125dcf321866bc2355a73773b11db8c9c","modified":1642695249654},{"_id":"public/js/search/local-search.js","hash":"72911c7b42e0174a979c09ead3f42ee24136feae","modified":1642695249654},{"_id":"public/css/index.css","hash":"9d4078c04f61140c79d0efd472ba1dc565046695","modified":1642695249654},{"_id":"public/js/main.js","hash":"1254dca2c02b3389ec0434cdd2728fdea4ae0216","modified":1642695249654},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1642695249654}],"Category":[{"name":"Java","_id":"ckyn6c72p0003gtnofcta0gns"}],"Data":[{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]}]}],"Page":[{"title":"分类","date":"2020-01-05T14:00:00.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-01-05 22:00:00\ntype: \"categories\"\n---","updated":"2022-01-20T16:13:52.232Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckyn6c72h0000gtnofaf1cm5g","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]}]}},"cover":"https://s3.charlesnote.com/cover/default_bg4.jpg","excerpt":"","more":""},{"title":"友情链接","date":"2020-09-05T16:13:11.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2020-09-06 00:13:11\ntype: \"link\"\n---","updated":"2022-01-20T16:13:52.232Z","path":"link/index.html","comments":1,"layout":"page","_id":"ckyn6c72n0002gtno2yvzhvwb","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]}]}},"cover":"https://s3.charlesnote.com/cover/default_bg4.jpg","excerpt":"","more":""},{"title":"标签","date":"2020-01-05T14:00:00.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-01-05 22:00:00\ntype: \"tags\"\n---","updated":"2022-01-20T16:13:52.232Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckyn6c72r0005gtno0zn59nd4","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]}]}},"cover":"https://s3.charlesnote.com/cover/default_bg2.jpg","excerpt":"","more":""}],"Post":[{"title":"Spring Ioc知识回顾","date":"2020-03-02T15:04:00.000Z","_content":"\n## What is IOC\n\n> 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）\n\n## Dependency Injection\n\n依赖注入\n\n关于什么是依赖\n\n关于注入和查找以及拖拽\n\n### 为什么要使用spring IOC\n\nspring体系结构----IOC的位置  自己看官网\n\n> 在日常程序开发过程当中，我们推荐面向抽象编程，面向抽象编程会产生类的依赖，当然如果你够强大可以自己写一个管理的容器，但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。\n\n当我们有了一个管理对象的容器之后，类的产生过程也交给了容器，至于我们自己的app则可以不需要去关系这些对象的产生了。\n\n## spring实现IOC的思路和方法\n\nspring实现IOC的思路是提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系，前提是对象之间的依赖关系必须在类中定义好，比如A.class中有一个B.class的属性，那么我们可以理解为A依赖了B。既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？\n\nspring实现IOC的思路大致可以拆分成3点\n\n1. 应用程序中提供类，提供依赖关系（属性或者构造方法）\n\n2. 把需要交给容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）\n\n3. 把各个类之间的依赖关系通过配置信息告诉容器\n\n配置这些信息的方法有三种分别是xml，annotation和javaconfig\n\n维护的过程称为自动注入，自动注入的方法有两种构造方法和setter\n\n自动注入的值可以是对象，数组，map，list和常量比如字符串整形等\n\n### spring编程的风格\n\n* schemal-based-------xml\n\n* annotation-based-----annotation\n\n* java-based----java Configuration\n\n### 注入的两种方法\n\nspring注入详细配置（字符串、数组等）参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed\n\n## Constructor-based Dependency Injection\n\n构造方法注入参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection\n\n![img](https://images-cdn.shimo.im/No88OKjKqfQIA1rz/image.png!thumbnail)\n\n## Setter-based Dependency Injection\n\nsetter参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection\n\n![img](https://images-cdn.shimo.im/WClSBbHC63UiHqpU/image.png!thumbnail)\n\n# 自动装配\n\n上面说过，IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。\n\n在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点\n\n自动装配的优点参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\n\n缺点参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions\n\n作为我来讲，我觉得以上缺点都不是缺点\n\n## 自动装配的方法\n\nno\n\nbyName\n\nbyType\n\nconstructor\n\n自动装配的方式参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\n\n![img](https://images-cdn.shimo.im/qyZgYw9KH7Iap0vt/image.png!thumbnail)\n\n## spring懒加载\n\n官网已经解释的非常清楚了：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init\n\n\n值得提醒的是，如果你想为所有的对都实现懒加载可以使用官网的配置\n\n![img](https://images-cdn.shimo.im/AL7NwUqEre0woKxB/image.png!thumbnail)\n\n## springbean的作用域\n\n文档参考：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes\n\n![img](https://images-cdn.shimo.im/z7bJcesJ7cMJeMvM/image.png!thumbnail)\n\nxml定义方式\n\n\n```xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/>\n```\n\nannotation的定义方式\n\n\n\n### Singleton Beans with Prototype-bean Dependencies\n\n意思是在Singleton 当中引用了一个Prototype的bean的时候引发的问题\n\n官网引导我们参考https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection\n\n## spring声明周期和回调\n\n参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle\n\n1. Methods annotated with @PostConstruct\n\n2. afterPropertiesSet() as defined by the InitializingBean callback interface\n\n3. A custom configured init() method","source":"_posts/spring-ioc-1.md","raw":"---\ntitle: Spring Ioc知识回顾\ndate: 2020-03-02 23:04:00\ncategories: Java\ntags: \n    - spring\n    - ioc\n    - aop\n---\n\n## What is IOC\n\n> 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）\n\n## Dependency Injection\n\n依赖注入\n\n关于什么是依赖\n\n关于注入和查找以及拖拽\n\n### 为什么要使用spring IOC\n\nspring体系结构----IOC的位置  自己看官网\n\n> 在日常程序开发过程当中，我们推荐面向抽象编程，面向抽象编程会产生类的依赖，当然如果你够强大可以自己写一个管理的容器，但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。\n\n当我们有了一个管理对象的容器之后，类的产生过程也交给了容器，至于我们自己的app则可以不需要去关系这些对象的产生了。\n\n## spring实现IOC的思路和方法\n\nspring实现IOC的思路是提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系，前提是对象之间的依赖关系必须在类中定义好，比如A.class中有一个B.class的属性，那么我们可以理解为A依赖了B。既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？\n\nspring实现IOC的思路大致可以拆分成3点\n\n1. 应用程序中提供类，提供依赖关系（属性或者构造方法）\n\n2. 把需要交给容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）\n\n3. 把各个类之间的依赖关系通过配置信息告诉容器\n\n配置这些信息的方法有三种分别是xml，annotation和javaconfig\n\n维护的过程称为自动注入，自动注入的方法有两种构造方法和setter\n\n自动注入的值可以是对象，数组，map，list和常量比如字符串整形等\n\n### spring编程的风格\n\n* schemal-based-------xml\n\n* annotation-based-----annotation\n\n* java-based----java Configuration\n\n### 注入的两种方法\n\nspring注入详细配置（字符串、数组等）参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed\n\n## Constructor-based Dependency Injection\n\n构造方法注入参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection\n\n![img](https://images-cdn.shimo.im/No88OKjKqfQIA1rz/image.png!thumbnail)\n\n## Setter-based Dependency Injection\n\nsetter参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection\n\n![img](https://images-cdn.shimo.im/WClSBbHC63UiHqpU/image.png!thumbnail)\n\n# 自动装配\n\n上面说过，IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。\n\n在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点\n\n自动装配的优点参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\n\n缺点参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions\n\n作为我来讲，我觉得以上缺点都不是缺点\n\n## 自动装配的方法\n\nno\n\nbyName\n\nbyType\n\nconstructor\n\n自动装配的方式参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\n\n![img](https://images-cdn.shimo.im/qyZgYw9KH7Iap0vt/image.png!thumbnail)\n\n## spring懒加载\n\n官网已经解释的非常清楚了：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init\n\n\n值得提醒的是，如果你想为所有的对都实现懒加载可以使用官网的配置\n\n![img](https://images-cdn.shimo.im/AL7NwUqEre0woKxB/image.png!thumbnail)\n\n## springbean的作用域\n\n文档参考：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes\n\n![img](https://images-cdn.shimo.im/z7bJcesJ7cMJeMvM/image.png!thumbnail)\n\nxml定义方式\n\n\n```xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/>\n```\n\nannotation的定义方式\n\n\n\n### Singleton Beans with Prototype-bean Dependencies\n\n意思是在Singleton 当中引用了一个Prototype的bean的时候引发的问题\n\n官网引导我们参考https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection\n\n## spring声明周期和回调\n\n参考文档：\n\nhttps://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle\n\n1. Methods annotated with @PostConstruct\n\n2. afterPropertiesSet() as defined by the InitializingBean callback interface\n\n3. A custom configured init() method","slug":"spring-ioc-1","published":1,"updated":"2022-01-20T16:13:52.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyn6c72k0001gtno1ity3u0y","content":"<h2 id=\"What-is-IOC\"><a href=\"#What-is-IOC\" class=\"headerlink\" title=\"What is IOC\"></a>What is IOC</h2><blockquote>\n<p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）</p>\n</blockquote>\n<h2 id=\"Dependency-Injection\"><a href=\"#Dependency-Injection\" class=\"headerlink\" title=\"Dependency Injection\"></a>Dependency Injection</h2><p>依赖注入</p>\n<p>关于什么是依赖</p>\n<p>关于注入和查找以及拖拽</p>\n<h3 id=\"为什么要使用spring-IOC\"><a href=\"#为什么要使用spring-IOC\" class=\"headerlink\" title=\"为什么要使用spring IOC\"></a>为什么要使用spring IOC</h3><p>spring体系结构—-IOC的位置  自己看官网</p>\n<blockquote>\n<p>在日常程序开发过程当中，我们推荐面向抽象编程，面向抽象编程会产生类的依赖，当然如果你够强大可以自己写一个管理的容器，但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。</p>\n</blockquote>\n<p>当我们有了一个管理对象的容器之后，类的产生过程也交给了容器，至于我们自己的app则可以不需要去关系这些对象的产生了。</p>\n<h2 id=\"spring实现IOC的思路和方法\"><a href=\"#spring实现IOC的思路和方法\" class=\"headerlink\" title=\"spring实现IOC的思路和方法\"></a>spring实现IOC的思路和方法</h2><p>spring实现IOC的思路是提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系，前提是对象之间的依赖关系必须在类中定义好，比如A.class中有一个B.class的属性，那么我们可以理解为A依赖了B。既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？</p>\n<p>spring实现IOC的思路大致可以拆分成3点</p>\n<ol>\n<li><p>应用程序中提供类，提供依赖关系（属性或者构造方法）</p>\n</li>\n<li><p>把需要交给容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）</p>\n</li>\n<li><p>把各个类之间的依赖关系通过配置信息告诉容器</p>\n</li>\n</ol>\n<p>配置这些信息的方法有三种分别是xml，annotation和javaconfig</p>\n<p>维护的过程称为自动注入，自动注入的方法有两种构造方法和setter</p>\n<p>自动注入的值可以是对象，数组，map，list和常量比如字符串整形等</p>\n<h3 id=\"spring编程的风格\"><a href=\"#spring编程的风格\" class=\"headerlink\" title=\"spring编程的风格\"></a>spring编程的风格</h3><ul>\n<li><p>schemal-based——-xml</p>\n</li>\n<li><p>annotation-based—–annotation</p>\n</li>\n<li><p>java-based—-java Configuration</p>\n</li>\n</ul>\n<h3 id=\"注入的两种方法\"><a href=\"#注入的两种方法\" class=\"headerlink\" title=\"注入的两种方法\"></a>注入的两种方法</h3><p>spring注入详细配置（字符串、数组等）参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed</a></p>\n<h2 id=\"Constructor-based-Dependency-Injection\"><a href=\"#Constructor-based-Dependency-Injection\" class=\"headerlink\" title=\"Constructor-based Dependency Injection\"></a>Constructor-based Dependency Injection</h2><p>构造方法注入参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection</a></p>\n<p><img src=\"https://images-cdn.shimo.im/No88OKjKqfQIA1rz/image.png!thumbnail\" alt=\"img\"></p>\n<h2 id=\"Setter-based-Dependency-Injection\"><a href=\"#Setter-based-Dependency-Injection\" class=\"headerlink\" title=\"Setter-based Dependency Injection\"></a>Setter-based Dependency Injection</h2><p>setter参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection</a></p>\n<p><img src=\"https://images-cdn.shimo.im/WClSBbHC63UiHqpU/image.png!thumbnail\" alt=\"img\"></p>\n<h1 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h1><p>上面说过，IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。</p>\n<p>在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点</p>\n<p>自动装配的优点参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>\n<p>缺点参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions</a></p>\n<p>作为我来讲，我觉得以上缺点都不是缺点</p>\n<h2 id=\"自动装配的方法\"><a href=\"#自动装配的方法\" class=\"headerlink\" title=\"自动装配的方法\"></a>自动装配的方法</h2><p>no</p>\n<p>byName</p>\n<p>byType</p>\n<p>constructor</p>\n<p>自动装配的方式参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>\n<p><img src=\"https://images-cdn.shimo.im/qyZgYw9KH7Iap0vt/image.png!thumbnail\" alt=\"img\"></p>\n<h2 id=\"spring懒加载\"><a href=\"#spring懒加载\" class=\"headerlink\" title=\"spring懒加载\"></a>spring懒加载</h2><p>官网已经解释的非常清楚了：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init</a></p>\n<p>值得提醒的是，如果你想为所有的对都实现懒加载可以使用官网的配置</p>\n<p><img src=\"https://images-cdn.shimo.im/AL7NwUqEre0woKxB/image.png!thumbnail\" alt=\"img\"></p>\n<h2 id=\"springbean的作用域\"><a href=\"#springbean的作用域\" class=\"headerlink\" title=\"springbean的作用域\"></a>springbean的作用域</h2><p>文档参考：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a></p>\n<p><img src=\"https://images-cdn.shimo.im/z7bJcesJ7cMJeMvM/image.png!thumbnail\" alt=\"img\"></p>\n<p>xml定义方式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;accountService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.something.DefaultAccountService&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>annotation的定义方式</p>\n<h3 id=\"Singleton-Beans-with-Prototype-bean-Dependencies\"><a href=\"#Singleton-Beans-with-Prototype-bean-Dependencies\" class=\"headerlink\" title=\"Singleton Beans with Prototype-bean Dependencies\"></a>Singleton Beans with Prototype-bean Dependencies</h3><p>意思是在Singleton 当中引用了一个Prototype的bean的时候引发的问题</p>\n<p>官网引导我们参考<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection</a></p>\n<h2 id=\"spring声明周期和回调\"><a href=\"#spring声明周期和回调\" class=\"headerlink\" title=\"spring声明周期和回调\"></a>spring声明周期和回调</h2><p>参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle</a></p>\n<ol>\n<li><p>Methods annotated with @PostConstruct</p>\n</li>\n<li><p>afterPropertiesSet() as defined by the InitializingBean callback interface</p>\n</li>\n<li><p>A custom configured init() method</p>\n</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]}]}},"cover":"https://s3.charlesnote.com/cover/default_bg4.jpg","excerpt":"","more":"<h2 id=\"What-is-IOC\"><a href=\"#What-is-IOC\" class=\"headerlink\" title=\"What is IOC\"></a>What is IOC</h2><blockquote>\n<p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）</p>\n</blockquote>\n<h2 id=\"Dependency-Injection\"><a href=\"#Dependency-Injection\" class=\"headerlink\" title=\"Dependency Injection\"></a>Dependency Injection</h2><p>依赖注入</p>\n<p>关于什么是依赖</p>\n<p>关于注入和查找以及拖拽</p>\n<h3 id=\"为什么要使用spring-IOC\"><a href=\"#为什么要使用spring-IOC\" class=\"headerlink\" title=\"为什么要使用spring IOC\"></a>为什么要使用spring IOC</h3><p>spring体系结构—-IOC的位置  自己看官网</p>\n<blockquote>\n<p>在日常程序开发过程当中，我们推荐面向抽象编程，面向抽象编程会产生类的依赖，当然如果你够强大可以自己写一个管理的容器，但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。</p>\n</blockquote>\n<p>当我们有了一个管理对象的容器之后，类的产生过程也交给了容器，至于我们自己的app则可以不需要去关系这些对象的产生了。</p>\n<h2 id=\"spring实现IOC的思路和方法\"><a href=\"#spring实现IOC的思路和方法\" class=\"headerlink\" title=\"spring实现IOC的思路和方法\"></a>spring实现IOC的思路和方法</h2><p>spring实现IOC的思路是提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系，前提是对象之间的依赖关系必须在类中定义好，比如A.class中有一个B.class的属性，那么我们可以理解为A依赖了B。既然我们在类中已经定义了他们之间的依赖关系那么为什么还需要在配置文件中去描述和定义呢？</p>\n<p>spring实现IOC的思路大致可以拆分成3点</p>\n<ol>\n<li><p>应用程序中提供类，提供依赖关系（属性或者构造方法）</p>\n</li>\n<li><p>把需要交给容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）</p>\n</li>\n<li><p>把各个类之间的依赖关系通过配置信息告诉容器</p>\n</li>\n</ol>\n<p>配置这些信息的方法有三种分别是xml，annotation和javaconfig</p>\n<p>维护的过程称为自动注入，自动注入的方法有两种构造方法和setter</p>\n<p>自动注入的值可以是对象，数组，map，list和常量比如字符串整形等</p>\n<h3 id=\"spring编程的风格\"><a href=\"#spring编程的风格\" class=\"headerlink\" title=\"spring编程的风格\"></a>spring编程的风格</h3><ul>\n<li><p>schemal-based——-xml</p>\n</li>\n<li><p>annotation-based—–annotation</p>\n</li>\n<li><p>java-based—-java Configuration</p>\n</li>\n</ul>\n<h3 id=\"注入的两种方法\"><a href=\"#注入的两种方法\" class=\"headerlink\" title=\"注入的两种方法\"></a>注入的两种方法</h3><p>spring注入详细配置（字符串、数组等）参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed</a></p>\n<h2 id=\"Constructor-based-Dependency-Injection\"><a href=\"#Constructor-based-Dependency-Injection\" class=\"headerlink\" title=\"Constructor-based Dependency Injection\"></a>Constructor-based Dependency Injection</h2><p>构造方法注入参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection</a></p>\n<p><img src=\"https://images-cdn.shimo.im/No88OKjKqfQIA1rz/image.png!thumbnail\" alt=\"img\"></p>\n<h2 id=\"Setter-based-Dependency-Injection\"><a href=\"#Setter-based-Dependency-Injection\" class=\"headerlink\" title=\"Setter-based Dependency Injection\"></a>Setter-based Dependency Injection</h2><p>setter参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection</a></p>\n<p><img src=\"https://images-cdn.shimo.im/WClSBbHC63UiHqpU/image.png!thumbnail\" alt=\"img\"></p>\n<h1 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h1><p>上面说过，IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。</p>\n<p>在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点</p>\n<p>自动装配的优点参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>\n<p>缺点参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions</a></p>\n<p>作为我来讲，我觉得以上缺点都不是缺点</p>\n<h2 id=\"自动装配的方法\"><a href=\"#自动装配的方法\" class=\"headerlink\" title=\"自动装配的方法\"></a>自动装配的方法</h2><p>no</p>\n<p>byName</p>\n<p>byType</p>\n<p>constructor</p>\n<p>自动装配的方式参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>\n<p><img src=\"https://images-cdn.shimo.im/qyZgYw9KH7Iap0vt/image.png!thumbnail\" alt=\"img\"></p>\n<h2 id=\"spring懒加载\"><a href=\"#spring懒加载\" class=\"headerlink\" title=\"spring懒加载\"></a>spring懒加载</h2><p>官网已经解释的非常清楚了：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init</a></p>\n<p>值得提醒的是，如果你想为所有的对都实现懒加载可以使用官网的配置</p>\n<p><img src=\"https://images-cdn.shimo.im/AL7NwUqEre0woKxB/image.png!thumbnail\" alt=\"img\"></p>\n<h2 id=\"springbean的作用域\"><a href=\"#springbean的作用域\" class=\"headerlink\" title=\"springbean的作用域\"></a>springbean的作用域</h2><p>文档参考：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a></p>\n<p><img src=\"https://images-cdn.shimo.im/z7bJcesJ7cMJeMvM/image.png!thumbnail\" alt=\"img\"></p>\n<p>xml定义方式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;accountService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.something.DefaultAccountService&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>annotation的定义方式</p>\n<h3 id=\"Singleton-Beans-with-Prototype-bean-Dependencies\"><a href=\"#Singleton-Beans-with-Prototype-bean-Dependencies\" class=\"headerlink\" title=\"Singleton Beans with Prototype-bean Dependencies\"></a>Singleton Beans with Prototype-bean Dependencies</h3><p>意思是在Singleton 当中引用了一个Prototype的bean的时候引发的问题</p>\n<p>官网引导我们参考<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection</a></p>\n<h2 id=\"spring声明周期和回调\"><a href=\"#spring声明周期和回调\" class=\"headerlink\" title=\"spring声明周期和回调\"></a>spring声明周期和回调</h2><p>参考文档：</p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle</a></p>\n<ol>\n<li><p>Methods annotated with @PostConstruct</p>\n</li>\n<li><p>afterPropertiesSet() as defined by the InitializingBean callback interface</p>\n</li>\n<li><p>A custom configured init() method</p>\n</li>\n</ol>\n"},{"title":"Java中的内存模型","date":"2020-03-01T15:09:04.000Z","_content":"## 一、基本概念\n\n### 程序\n\n由代码编译成功得到的二进制文件。在Windows中就是.exe文件。程序只占用磁盘空间。 这是一个静态的概念。\n\n### 进程\n\n运行起来的程序。进程需要占用系统资源（内存，CPU）。**进程是最小的系统资源分配单位**，只是给线程提供执行环境。 这是一个动态的概念\n\n>  由于一个进程产生一个进程地址空间，且进程地址空间相互独立，一个进程死亡，其他进程不会受到影响。\n\n#### 进程的状态变更\n\n![](https://s3.charlesnote.com/bak/FvhDrmv6baLquaN1f68BIUT1RNN8)\n\n### 线程\n\nLWP（light weight process）轻量级进程。**线程是最小的执行单位**。CPU分配时间轮片的对象。\n\n产生原因：提高争夺到CPU的概率。\n\n![](https://s3.charlesnote.com/bak/FqYjg9vQLvrYBse44rBOINfmRcVn)\n\n### 协程\n\ncoroutine，也叫轻量级线程。 与传统的系统级线程和进程相比，携程最大的优势在于“轻量级”，可以轻松创建上万个而不会导致系统资源衰歇。而线程和进程通常很难超过1万个。一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。\n\n产生原因：提高程序执行的效率。（利用闲暇时间执行其他任务）\n\n> go协程：叫goroutine。在进程中创建。它比线程更小，十几个goroutine可能体现在底层就是五六个线程，go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需要极少的栈内存（大概4~5kb），当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用，更高效，更轻便。一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松的让成百上千个goroutine进行资源竞争。\n\n## 二、Java线程与系统线程的关系\n\n### 操作系统线程状态\n\n操作系统中的线程除去new和terminated状态，一个线程真实存在的状态，只有：\n\n- ready：表示线程已经被创建，正在等待系统调度分配CPU使用权。\n- running：表示线程获得了CPU使用权，正在进行运算\n- waiting：表示线程等待（或者说挂起），让出CPU资源给其他线程使用\n\n\n> 为什么除去new和terminated状态？\n> 是因为这两种状态实际上并不存在于线程运行中，所以也没什么实际讨论的意义\n\n### Java中的线程状态\n无论是`Timed Waiting` ，`Waiting`还是`Blocked`，对应的都是操作系统线程的`waiting(等待)`状态。而`Runnable`状态，则对应了操作系统中的`ready`和`running`状态。\n\nJava语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下：\n\n* 新建（New）：创建后尚未启动的线程处于这种状态。\n\n* 运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。\n* 阻塞（Blocked）：线程阻塞于锁\n\n* 无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其它线程显示地唤醒。以下方法会让线程陷入无限期的等待状态：\n  * 没有设置Timeout参数的Object.wait()方法\n  * 没有设置Timeout参数的Thread.join()方法\n  * LockSupport.park()方法\n\n* 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其它线程显示地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：\n  * Thread.sleep()方法\n  * 设置了Timeout参数的Object.wait()方法\n  * 设置了Timeout参数的Thread.join()方法\n  * LockSupport.parkNanos()方法\n  * LockSupport.parkUntil()方法\n\n### 总结\n\n而对不同的操作系统，由于本身设计思路不一样，对于线程的设计也存在种种差异，所以JVM在设计上，就已经声明：\n\n>  **JVM虚拟机中的线程状态，不反应任何操作系统线程状态**\n\n## 三、JVM的内存结构\n\n![](https://s3.charlesnote.com/bak/Fief69LdYrWe_TRdkcvcqcIPQxsZ)\n\n按照JVM规范，JVM内存分为以下五个区域\n\n### 程序计数器\n\n程序计数器是一块很小的内存空间，它是**线程私有**的，可以认作为当前线程的行号指示器。\n\n**为什么需要程序计数器**\n\n> 我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。\n>\n> 注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。**这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域**。\n\n### Java栈（虚拟机栈）\n\n同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，**栈描述的是Java方法执行的内存模型**。\n\n**每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。【栈先进后出】**\n\n##### 栈帧\n\n> 栈帧: 是用来存储数据和部分过程结果的数据结构。\n> 栈帧的位置:  内存 -> 运行时数据区 -> 某个线程对应的虚拟机栈 -> here[在这里]\n> 栈帧大小确定时间: 编译期确定，不受运行期数据影响。\n\n**平时说的栈一般指局部变量表部分。**\n\n局部变量表:一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。它的最小的局部变量表空间单位为Slot，虚拟机没有指明Slot的大小，但在jvm中，long和double类型数据明确规定为64位，这两个类型占2个Slot，其它基本类型固定占用1个Slot。\n\nreference类型:与基本类型不同的是它不等同本身，即使是String，内部也是char数组组成，它可能是指向一个对象起始位置指针，也可能指向一个代表对象的句柄或其他与该对象有关的位置。\n\nreturnAddress类型:指向一条字节码指令的地址【深入理解Java虚拟机】[怎么理解returnAddress](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F29056872)\n\n![](https://s3.charlesnote.com/bak/Ft8GzLecmWmAd8X5Em3GkOmIyZKZ)\n\n\n\n### 本地方法栈\n\n本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。\n\n### 堆\n\n对于大多数应用来说，**堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制**。\n\njava虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。\n\n> 即时编译器:可以把Java的字节码，包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序)\n>\n> 逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。\n\n注意:它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代，再细致点还有Eden(伊甸园)空间之类的不做深究。\n\n根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。\n\n当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)\n\n### 方法区\n\n方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。\n\n用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。\n\n> 运行时常量池\n>\n> 是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。\n\n在老版jdk，方法区的实现是永久代【因为没有强制要求方法区必须实现垃圾回收，HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。JDK8之后改为了metadata space（元数据空间）】\n\n\n\n## 四、Java内存模型（JMM）\n\n![](https://s3.charlesnote.com/bak/FvZP0DodmgC-YLN-izgTp3PwDmJQ)\n\n1. 主内存：共享的信息\n\n2. 工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中\n\n3. 工作方式：\n   1. 线程修改私有数据，直接在工作空间修改\n   2. 线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据\n\n## 五、硬件结构\n\n![](https://s3.charlesnote.com/bak/Fr9Qc5zY63C7x94rXJKTTmDOfbhy)\n\n* CPU缓存的一致性问题：并发处理的不同步\n* 解决方案：\n  * 总线加锁（ 降低CPU的吞吐量）\n  * 缓存上的一致性协议（MESI）\n\n### Cache的写方式\n\n1. write through（写通）：每次CPU修改了cache中的内容，立即更新到内存，也就意味着每次CPU写共享数据，都会导致总线事务，因此这种方式常常会引起总线事务的竞争，高一致性，但是效率非常低；\n2. write back（写回）：每次CPU修改了cache中的数据，不会立即更新到内存，而是等到cache line在某一个必须或合适的时机才会更新到内存中；\n\n> 无论是写通还是写回，在多线程环境下都需要处理缓存cache一致性问题。为了保证缓存一致性，处理器又提供了写失效（write invalidate）和写更新（write update）两个操作来保证cache一致性。\n\n3. 写失效：当一个CPU修改了数据，如果其他CPU有该数据，则通知其为无效；\n\n4. 写更新：当一个CPU修改了数据，如果其他CPU有该数据，则通知其跟新数据；\n\n>  写更新会导致大量的更新操作，因此在MESI协议中，采取的是写失效（即MESI中的I：ivalid，如果采用的是写更新，那么就不是MESI协议了，而是MESU协议）。\n\n### 缓存一致性协议（MESI）\n\n简单理解：当CPU在CACHE中操作数据时，如果该数据是共享变量，数据在CACHE读到寄存器中，进行新修改，并更新内存数据，CACHE LINE置无效，其他的CPU就从内存中读数据\n\n缓存一致性：在多核CPU中，内存中的数据会在多个核心中存在数据副本，某一个核心发生修改操作，就产生了数据不一致的问题。而一致性协议正是用于保证多个CPU cache之间缓存共享数据的一致。\n\n> MESI，则是缓存一致性协议中的一个，到底怎么实现，还是得看具体的处理器指令集。\n\n#### Cache的状态\n\n```text\nI: Invalid（无效），该CPU中该Cache字段失效\nS: Shared（共享），多个CPU的Cache均共享该数据\nE: Exclusive（独占），数据只在该CPU独有，其它CPU变为Invalid状态\nM: Modified（已修改），与E状态类似，但是数据已经被修改，在其变为Invalid状态时，需要先将数据回写到内存 \n```\n\n#### 状态机\n\n![](https://s3.charlesnote.com/bak/FkWs6x0Gqchk3l0u0fC7PR931xLU)\n\n## 六、并发编程的三个重要特性\n\n1. 原子性：不可分割 （x=1）\n2. 可见性：线程只能操作自己工作空间中的数据\n3. 有序性：程序中的顺序不一定就是执行的顺序\n   1. 编译重排序\n   2. 指令重排序（处理器重排序）\n\n### as-if-serial规则\n\nas-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。\n\n为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：\n\n``` java\ndouble pi  = 3.14;    //A\ndouble r   = 1.0;     //B\ndouble area = pi * r * r; //C\n```\n\n\nA和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同让编写单线程程序的程序员产生了一个幻觉：单线程程序是按程序的顺序来执行的**。**as-if-serial语义使程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。\n\n\n### happens-before规则\n\n上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。\n\n\nJMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：\n\n1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\n\n2. 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。\n\n上面的1）是JMM对程序员的承诺。\n\n从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。**注意，这只是Java内存模型向程序员做出的保证**\n\n上面的2）是JMM对编译器和处理器重排序的约束原则。\n\n正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。\n\n### 具体规则\n\n1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。\n2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。\n3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。\n4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。\n5. start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。\n6. join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。\n7. 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。\n8. 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。\n\n### JMM对三个特性保证\n\n#### JMM与原子性\n\n* X=10 写 原子性  如果是私有数据具有原子性，如果是共享数据没原子性（读写） \n*  Y=x 没有原子性\n  * 把数据X读到工作空间（原子性）\n  * 把X的值写到Y（原子性）\n*  I++ 没有原子性\n  * 读i到工作空间\n  *  +1；\n  * 刷新结果到内存\n* Z=z+1 没有原子性\n  * 读z到工作空间\n  * +1；\n  * 刷新结果到内存\n\n> 多个原子性的操作合并到一起没有原子性\n\n保证方式：\n1. Synchronized\n2. JUC  Lock的lock\n\n####  JMM与可见性\n1. Volatile:在JMM模型上实现MESI协议\n2. Synchronized:加锁\n3. JUC  JUC  Lock的lock\n\n#### JMM与有序性\n1. Volatile\n2. Synchronized","source":"_posts/jvm-note-1.md","raw":"---\ntitle: Java中的内存模型\ndate: 2020-03-01 23:09:04\ncategories: Java\ntags:\n    - JVM\n    - 内存模型\n---\n## 一、基本概念\n\n### 程序\n\n由代码编译成功得到的二进制文件。在Windows中就是.exe文件。程序只占用磁盘空间。 这是一个静态的概念。\n\n### 进程\n\n运行起来的程序。进程需要占用系统资源（内存，CPU）。**进程是最小的系统资源分配单位**，只是给线程提供执行环境。 这是一个动态的概念\n\n>  由于一个进程产生一个进程地址空间，且进程地址空间相互独立，一个进程死亡，其他进程不会受到影响。\n\n#### 进程的状态变更\n\n![](https://s3.charlesnote.com/bak/FvhDrmv6baLquaN1f68BIUT1RNN8)\n\n### 线程\n\nLWP（light weight process）轻量级进程。**线程是最小的执行单位**。CPU分配时间轮片的对象。\n\n产生原因：提高争夺到CPU的概率。\n\n![](https://s3.charlesnote.com/bak/FqYjg9vQLvrYBse44rBOINfmRcVn)\n\n### 协程\n\ncoroutine，也叫轻量级线程。 与传统的系统级线程和进程相比，携程最大的优势在于“轻量级”，可以轻松创建上万个而不会导致系统资源衰歇。而线程和进程通常很难超过1万个。一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。\n\n产生原因：提高程序执行的效率。（利用闲暇时间执行其他任务）\n\n> go协程：叫goroutine。在进程中创建。它比线程更小，十几个goroutine可能体现在底层就是五六个线程，go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需要极少的栈内存（大概4~5kb），当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用，更高效，更轻便。一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松的让成百上千个goroutine进行资源竞争。\n\n## 二、Java线程与系统线程的关系\n\n### 操作系统线程状态\n\n操作系统中的线程除去new和terminated状态，一个线程真实存在的状态，只有：\n\n- ready：表示线程已经被创建，正在等待系统调度分配CPU使用权。\n- running：表示线程获得了CPU使用权，正在进行运算\n- waiting：表示线程等待（或者说挂起），让出CPU资源给其他线程使用\n\n\n> 为什么除去new和terminated状态？\n> 是因为这两种状态实际上并不存在于线程运行中，所以也没什么实际讨论的意义\n\n### Java中的线程状态\n无论是`Timed Waiting` ，`Waiting`还是`Blocked`，对应的都是操作系统线程的`waiting(等待)`状态。而`Runnable`状态，则对应了操作系统中的`ready`和`running`状态。\n\nJava语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下：\n\n* 新建（New）：创建后尚未启动的线程处于这种状态。\n\n* 运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。\n* 阻塞（Blocked）：线程阻塞于锁\n\n* 无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其它线程显示地唤醒。以下方法会让线程陷入无限期的等待状态：\n  * 没有设置Timeout参数的Object.wait()方法\n  * 没有设置Timeout参数的Thread.join()方法\n  * LockSupport.park()方法\n\n* 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其它线程显示地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：\n  * Thread.sleep()方法\n  * 设置了Timeout参数的Object.wait()方法\n  * 设置了Timeout参数的Thread.join()方法\n  * LockSupport.parkNanos()方法\n  * LockSupport.parkUntil()方法\n\n### 总结\n\n而对不同的操作系统，由于本身设计思路不一样，对于线程的设计也存在种种差异，所以JVM在设计上，就已经声明：\n\n>  **JVM虚拟机中的线程状态，不反应任何操作系统线程状态**\n\n## 三、JVM的内存结构\n\n![](https://s3.charlesnote.com/bak/Fief69LdYrWe_TRdkcvcqcIPQxsZ)\n\n按照JVM规范，JVM内存分为以下五个区域\n\n### 程序计数器\n\n程序计数器是一块很小的内存空间，它是**线程私有**的，可以认作为当前线程的行号指示器。\n\n**为什么需要程序计数器**\n\n> 我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。\n>\n> 注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。**这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域**。\n\n### Java栈（虚拟机栈）\n\n同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，**栈描述的是Java方法执行的内存模型**。\n\n**每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。【栈先进后出】**\n\n##### 栈帧\n\n> 栈帧: 是用来存储数据和部分过程结果的数据结构。\n> 栈帧的位置:  内存 -> 运行时数据区 -> 某个线程对应的虚拟机栈 -> here[在这里]\n> 栈帧大小确定时间: 编译期确定，不受运行期数据影响。\n\n**平时说的栈一般指局部变量表部分。**\n\n局部变量表:一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。它的最小的局部变量表空间单位为Slot，虚拟机没有指明Slot的大小，但在jvm中，long和double类型数据明确规定为64位，这两个类型占2个Slot，其它基本类型固定占用1个Slot。\n\nreference类型:与基本类型不同的是它不等同本身，即使是String，内部也是char数组组成，它可能是指向一个对象起始位置指针，也可能指向一个代表对象的句柄或其他与该对象有关的位置。\n\nreturnAddress类型:指向一条字节码指令的地址【深入理解Java虚拟机】[怎么理解returnAddress](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F29056872)\n\n![](https://s3.charlesnote.com/bak/Ft8GzLecmWmAd8X5Em3GkOmIyZKZ)\n\n\n\n### 本地方法栈\n\n本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。\n\n### 堆\n\n对于大多数应用来说，**堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制**。\n\njava虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。\n\n> 即时编译器:可以把Java的字节码，包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序)\n>\n> 逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。\n\n注意:它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代，再细致点还有Eden(伊甸园)空间之类的不做深究。\n\n根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。\n\n当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)\n\n### 方法区\n\n方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。\n\n用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。\n\n> 运行时常量池\n>\n> 是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。\n\n在老版jdk，方法区的实现是永久代【因为没有强制要求方法区必须实现垃圾回收，HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。JDK8之后改为了metadata space（元数据空间）】\n\n\n\n## 四、Java内存模型（JMM）\n\n![](https://s3.charlesnote.com/bak/FvZP0DodmgC-YLN-izgTp3PwDmJQ)\n\n1. 主内存：共享的信息\n\n2. 工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中\n\n3. 工作方式：\n   1. 线程修改私有数据，直接在工作空间修改\n   2. 线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据\n\n## 五、硬件结构\n\n![](https://s3.charlesnote.com/bak/Fr9Qc5zY63C7x94rXJKTTmDOfbhy)\n\n* CPU缓存的一致性问题：并发处理的不同步\n* 解决方案：\n  * 总线加锁（ 降低CPU的吞吐量）\n  * 缓存上的一致性协议（MESI）\n\n### Cache的写方式\n\n1. write through（写通）：每次CPU修改了cache中的内容，立即更新到内存，也就意味着每次CPU写共享数据，都会导致总线事务，因此这种方式常常会引起总线事务的竞争，高一致性，但是效率非常低；\n2. write back（写回）：每次CPU修改了cache中的数据，不会立即更新到内存，而是等到cache line在某一个必须或合适的时机才会更新到内存中；\n\n> 无论是写通还是写回，在多线程环境下都需要处理缓存cache一致性问题。为了保证缓存一致性，处理器又提供了写失效（write invalidate）和写更新（write update）两个操作来保证cache一致性。\n\n3. 写失效：当一个CPU修改了数据，如果其他CPU有该数据，则通知其为无效；\n\n4. 写更新：当一个CPU修改了数据，如果其他CPU有该数据，则通知其跟新数据；\n\n>  写更新会导致大量的更新操作，因此在MESI协议中，采取的是写失效（即MESI中的I：ivalid，如果采用的是写更新，那么就不是MESI协议了，而是MESU协议）。\n\n### 缓存一致性协议（MESI）\n\n简单理解：当CPU在CACHE中操作数据时，如果该数据是共享变量，数据在CACHE读到寄存器中，进行新修改，并更新内存数据，CACHE LINE置无效，其他的CPU就从内存中读数据\n\n缓存一致性：在多核CPU中，内存中的数据会在多个核心中存在数据副本，某一个核心发生修改操作，就产生了数据不一致的问题。而一致性协议正是用于保证多个CPU cache之间缓存共享数据的一致。\n\n> MESI，则是缓存一致性协议中的一个，到底怎么实现，还是得看具体的处理器指令集。\n\n#### Cache的状态\n\n```text\nI: Invalid（无效），该CPU中该Cache字段失效\nS: Shared（共享），多个CPU的Cache均共享该数据\nE: Exclusive（独占），数据只在该CPU独有，其它CPU变为Invalid状态\nM: Modified（已修改），与E状态类似，但是数据已经被修改，在其变为Invalid状态时，需要先将数据回写到内存 \n```\n\n#### 状态机\n\n![](https://s3.charlesnote.com/bak/FkWs6x0Gqchk3l0u0fC7PR931xLU)\n\n## 六、并发编程的三个重要特性\n\n1. 原子性：不可分割 （x=1）\n2. 可见性：线程只能操作自己工作空间中的数据\n3. 有序性：程序中的顺序不一定就是执行的顺序\n   1. 编译重排序\n   2. 指令重排序（处理器重排序）\n\n### as-if-serial规则\n\nas-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。\n\n为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：\n\n``` java\ndouble pi  = 3.14;    //A\ndouble r   = 1.0;     //B\ndouble area = pi * r * r; //C\n```\n\n\nA和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同让编写单线程程序的程序员产生了一个幻觉：单线程程序是按程序的顺序来执行的**。**as-if-serial语义使程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。\n\n\n### happens-before规则\n\n上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。\n\n\nJMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：\n\n1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\n\n2. 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。\n\n上面的1）是JMM对程序员的承诺。\n\n从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。**注意，这只是Java内存模型向程序员做出的保证**\n\n上面的2）是JMM对编译器和处理器重排序的约束原则。\n\n正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。\n\n### 具体规则\n\n1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。\n2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。\n3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。\n4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。\n5. start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。\n6. join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。\n7. 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。\n8. 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。\n\n### JMM对三个特性保证\n\n#### JMM与原子性\n\n* X=10 写 原子性  如果是私有数据具有原子性，如果是共享数据没原子性（读写） \n*  Y=x 没有原子性\n  * 把数据X读到工作空间（原子性）\n  * 把X的值写到Y（原子性）\n*  I++ 没有原子性\n  * 读i到工作空间\n  *  +1；\n  * 刷新结果到内存\n* Z=z+1 没有原子性\n  * 读z到工作空间\n  * +1；\n  * 刷新结果到内存\n\n> 多个原子性的操作合并到一起没有原子性\n\n保证方式：\n1. Synchronized\n2. JUC  Lock的lock\n\n####  JMM与可见性\n1. Volatile:在JMM模型上实现MESI协议\n2. Synchronized:加锁\n3. JUC  JUC  Lock的lock\n\n#### JMM与有序性\n1. Volatile\n2. Synchronized","slug":"jvm-note-1","published":1,"updated":"2022-01-20T16:13:52.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyn6c73e000cgtno86cr7nmw","content":"<h2 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h2><h3 id=\"程序\"><a href=\"#程序\" class=\"headerlink\" title=\"程序\"></a>程序</h3><p>由代码编译成功得到的二进制文件。在Windows中就是.exe文件。程序只占用磁盘空间。 这是一个静态的概念。</p>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><p>运行起来的程序。进程需要占用系统资源（内存，CPU）。<strong>进程是最小的系统资源分配单位</strong>，只是给线程提供执行环境。 这是一个动态的概念</p>\n<blockquote>\n<p> 由于一个进程产生一个进程地址空间，且进程地址空间相互独立，一个进程死亡，其他进程不会受到影响。</p>\n</blockquote>\n<h4 id=\"进程的状态变更\"><a href=\"#进程的状态变更\" class=\"headerlink\" title=\"进程的状态变更\"></a>进程的状态变更</h4><p><img src=\"https://s3.charlesnote.com/bak/FvhDrmv6baLquaN1f68BIUT1RNN8\"></p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><p>LWP（light weight process）轻量级进程。<strong>线程是最小的执行单位</strong>。CPU分配时间轮片的对象。</p>\n<p>产生原因：提高争夺到CPU的概率。</p>\n<p><img src=\"https://s3.charlesnote.com/bak/FqYjg9vQLvrYBse44rBOINfmRcVn\"></p>\n<h3 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h3><p>coroutine，也叫轻量级线程。 与传统的系统级线程和进程相比，携程最大的优势在于“轻量级”，可以轻松创建上万个而不会导致系统资源衰歇。而线程和进程通常很难超过1万个。一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。</p>\n<p>产生原因：提高程序执行的效率。（利用闲暇时间执行其他任务）</p>\n<blockquote>\n<p>go协程：叫goroutine。在进程中创建。它比线程更小，十几个goroutine可能体现在底层就是五六个线程，go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需要极少的栈内存（大概4~5kb），当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用，更高效，更轻便。一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松的让成百上千个goroutine进行资源竞争。</p>\n</blockquote>\n<h2 id=\"二、Java线程与系统线程的关系\"><a href=\"#二、Java线程与系统线程的关系\" class=\"headerlink\" title=\"二、Java线程与系统线程的关系\"></a>二、Java线程与系统线程的关系</h2><h3 id=\"操作系统线程状态\"><a href=\"#操作系统线程状态\" class=\"headerlink\" title=\"操作系统线程状态\"></a>操作系统线程状态</h3><p>操作系统中的线程除去new和terminated状态，一个线程真实存在的状态，只有：</p>\n<ul>\n<li>ready：表示线程已经被创建，正在等待系统调度分配CPU使用权。</li>\n<li>running：表示线程获得了CPU使用权，正在进行运算</li>\n<li>waiting：表示线程等待（或者说挂起），让出CPU资源给其他线程使用</li>\n</ul>\n<blockquote>\n<p>为什么除去new和terminated状态？<br>是因为这两种状态实际上并不存在于线程运行中，所以也没什么实际讨论的意义</p>\n</blockquote>\n<h3 id=\"Java中的线程状态\"><a href=\"#Java中的线程状态\" class=\"headerlink\" title=\"Java中的线程状态\"></a>Java中的线程状态</h3><p>无论是<code>Timed Waiting</code> ，<code>Waiting</code>还是<code>Blocked</code>，对应的都是操作系统线程的<code>waiting(等待)</code>状态。而<code>Runnable</code>状态，则对应了操作系统中的<code>ready</code>和<code>running</code>状态。</p>\n<p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下：</p>\n<ul>\n<li><p>新建（New）：创建后尚未启动的线程处于这种状态。</p>\n</li>\n<li><p>运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</p>\n</li>\n<li><p>阻塞（Blocked）：线程阻塞于锁</p>\n</li>\n<li><p>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其它线程显示地唤醒。以下方法会让线程陷入无限期的等待状态：</p>\n<ul>\n<li>没有设置Timeout参数的Object.wait()方法</li>\n<li>没有设置Timeout参数的Thread.join()方法</li>\n<li>LockSupport.park()方法</li>\n</ul>\n</li>\n<li><p>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其它线程显示地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p>\n<ul>\n<li>Thread.sleep()方法</li>\n<li>设置了Timeout参数的Object.wait()方法</li>\n<li>设置了Timeout参数的Thread.join()方法</li>\n<li>LockSupport.parkNanos()方法</li>\n<li>LockSupport.parkUntil()方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>而对不同的操作系统，由于本身设计思路不一样，对于线程的设计也存在种种差异，所以JVM在设计上，就已经声明：</p>\n<blockquote>\n<p> <strong>JVM虚拟机中的线程状态，不反应任何操作系统线程状态</strong></p>\n</blockquote>\n<h2 id=\"三、JVM的内存结构\"><a href=\"#三、JVM的内存结构\" class=\"headerlink\" title=\"三、JVM的内存结构\"></a>三、JVM的内存结构</h2><p><img src=\"https://s3.charlesnote.com/bak/Fief69LdYrWe_TRdkcvcqcIPQxsZ\"></p>\n<p>按照JVM规范，JVM内存分为以下五个区域</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是一块很小的内存空间，它是<strong>线程私有</strong>的，可以认作为当前线程的行号指示器。</p>\n<p><strong>为什么需要程序计数器</strong></p>\n<blockquote>\n<p>我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。</p>\n<p>注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。<strong>这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域</strong>。</p>\n</blockquote>\n<h3 id=\"Java栈（虚拟机栈）\"><a href=\"#Java栈（虚拟机栈）\" class=\"headerlink\" title=\"Java栈（虚拟机栈）\"></a>Java栈（虚拟机栈）</h3><p>同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，<strong>栈描述的是Java方法执行的内存模型</strong>。</p>\n<p><strong>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。【栈先进后出】</strong></p>\n<h5 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h5><blockquote>\n<p>栈帧: 是用来存储数据和部分过程结果的数据结构。<br>栈帧的位置:  内存 -&gt; 运行时数据区 -&gt; 某个线程对应的虚拟机栈 -&gt; here[在这里]<br>栈帧大小确定时间: 编译期确定，不受运行期数据影响。</p>\n</blockquote>\n<p><strong>平时说的栈一般指局部变量表部分。</strong></p>\n<p>局部变量表:一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。它的最小的局部变量表空间单位为Slot，虚拟机没有指明Slot的大小，但在jvm中，long和double类型数据明确规定为64位，这两个类型占2个Slot，其它基本类型固定占用1个Slot。</p>\n<p>reference类型:与基本类型不同的是它不等同本身，即使是String，内部也是char数组组成，它可能是指向一个对象起始位置指针，也可能指向一个代表对象的句柄或其他与该对象有关的位置。</p>\n<p>returnAddress类型:指向一条字节码指令的地址【深入理解Java虚拟机】<a href=\"https://links.jianshu.com/go?to=https://www.zhihu.com/question/29056872\">怎么理解returnAddress</a></p>\n<p><img src=\"https://s3.charlesnote.com/bak/Ft8GzLecmWmAd8X5Em3GkOmIyZKZ\"></p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>对于大多数应用来说，<strong>堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制</strong>。</p>\n<p>java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。</p>\n<blockquote>\n<p>即时编译器:可以把Java的字节码，包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序)</p>\n<p>逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。</p>\n</blockquote>\n<p>注意:它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代，再细致点还有Eden(伊甸园)空间之类的不做深究。</p>\n<p>根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。</p>\n<p>当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。</p>\n<p>用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。</p>\n<blockquote>\n<p>运行时常量池</p>\n<p>是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。</p>\n</blockquote>\n<p>在老版jdk，方法区的实现是永久代【因为没有强制要求方法区必须实现垃圾回收，HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。JDK8之后改为了metadata space（元数据空间）】</p>\n<h2 id=\"四、Java内存模型（JMM）\"><a href=\"#四、Java内存模型（JMM）\" class=\"headerlink\" title=\"四、Java内存模型（JMM）\"></a>四、Java内存模型（JMM）</h2><p><img src=\"https://s3.charlesnote.com/bak/FvZP0DodmgC-YLN-izgTp3PwDmJQ\"></p>\n<ol>\n<li><p>主内存：共享的信息</p>\n</li>\n<li><p>工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中</p>\n</li>\n<li><p>工作方式：</p>\n<ol>\n<li>线程修改私有数据，直接在工作空间修改</li>\n<li>线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"五、硬件结构\"><a href=\"#五、硬件结构\" class=\"headerlink\" title=\"五、硬件结构\"></a>五、硬件结构</h2><p><img src=\"https://s3.charlesnote.com/bak/Fr9Qc5zY63C7x94rXJKTTmDOfbhy\"></p>\n<ul>\n<li>CPU缓存的一致性问题：并发处理的不同步</li>\n<li>解决方案：<ul>\n<li>总线加锁（ 降低CPU的吞吐量）</li>\n<li>缓存上的一致性协议（MESI）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Cache的写方式\"><a href=\"#Cache的写方式\" class=\"headerlink\" title=\"Cache的写方式\"></a>Cache的写方式</h3><ol>\n<li>write through（写通）：每次CPU修改了cache中的内容，立即更新到内存，也就意味着每次CPU写共享数据，都会导致总线事务，因此这种方式常常会引起总线事务的竞争，高一致性，但是效率非常低；</li>\n<li>write back（写回）：每次CPU修改了cache中的数据，不会立即更新到内存，而是等到cache line在某一个必须或合适的时机才会更新到内存中；</li>\n</ol>\n<blockquote>\n<p>无论是写通还是写回，在多线程环境下都需要处理缓存cache一致性问题。为了保证缓存一致性，处理器又提供了写失效（write invalidate）和写更新（write update）两个操作来保证cache一致性。</p>\n</blockquote>\n<ol start=\"3\">\n<li><p>写失效：当一个CPU修改了数据，如果其他CPU有该数据，则通知其为无效；</p>\n</li>\n<li><p>写更新：当一个CPU修改了数据，如果其他CPU有该数据，则通知其跟新数据；</p>\n</li>\n</ol>\n<blockquote>\n<p> 写更新会导致大量的更新操作，因此在MESI协议中，采取的是写失效（即MESI中的I：ivalid，如果采用的是写更新，那么就不是MESI协议了，而是MESU协议）。</p>\n</blockquote>\n<h3 id=\"缓存一致性协议（MESI）\"><a href=\"#缓存一致性协议（MESI）\" class=\"headerlink\" title=\"缓存一致性协议（MESI）\"></a>缓存一致性协议（MESI）</h3><p>简单理解：当CPU在CACHE中操作数据时，如果该数据是共享变量，数据在CACHE读到寄存器中，进行新修改，并更新内存数据，CACHE LINE置无效，其他的CPU就从内存中读数据</p>\n<p>缓存一致性：在多核CPU中，内存中的数据会在多个核心中存在数据副本，某一个核心发生修改操作，就产生了数据不一致的问题。而一致性协议正是用于保证多个CPU cache之间缓存共享数据的一致。</p>\n<blockquote>\n<p>MESI，则是缓存一致性协议中的一个，到底怎么实现，还是得看具体的处理器指令集。</p>\n</blockquote>\n<h4 id=\"Cache的状态\"><a href=\"#Cache的状态\" class=\"headerlink\" title=\"Cache的状态\"></a>Cache的状态</h4><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I: Invalid（无效），该CPU中该Cache字段失效</span><br><span class=\"line\">S: Shared（共享），多个CPU的Cache均共享该数据</span><br><span class=\"line\">E: Exclusive（独占），数据只在该CPU独有，其它CPU变为Invalid状态</span><br><span class=\"line\">M: Modified（已修改），与E状态类似，但是数据已经被修改，在其变为Invalid状态时，需要先将数据回写到内存 </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"状态机\"><a href=\"#状态机\" class=\"headerlink\" title=\"状态机\"></a>状态机</h4><p><img src=\"https://s3.charlesnote.com/bak/FkWs6x0Gqchk3l0u0fC7PR931xLU\"></p>\n<h2 id=\"六、并发编程的三个重要特性\"><a href=\"#六、并发编程的三个重要特性\" class=\"headerlink\" title=\"六、并发编程的三个重要特性\"></a>六、并发编程的三个重要特性</h2><ol>\n<li>原子性：不可分割 （x=1）</li>\n<li>可见性：线程只能操作自己工作空间中的数据</li>\n<li>有序性：程序中的顺序不一定就是执行的顺序<ol>\n<li>编译重排序</li>\n<li>指令重排序（处理器重排序）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"as-if-serial规则\"><a href=\"#as-if-serial规则\" class=\"headerlink\" title=\"as-if-serial规则\"></a>as-if-serial规则</h3><p>as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p>\n<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> pi  = <span class=\"number\">3.14</span>;    <span class=\"comment\">//A</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> r   = <span class=\"number\">1.0</span>;     <span class=\"comment\">//B</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> area = pi * r * r; <span class=\"comment\">//C</span></span><br></pre></td></tr></table></figure>\n\n\n<p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同让编写单线程程序的程序员产生了一个幻觉：单线程程序是按程序的顺序来执行的<strong>。</strong>as-if-serial语义使程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>\n<h3 id=\"happens-before规则\"><a href=\"#happens-before规则\" class=\"headerlink\" title=\"happens-before规则\"></a>happens-before规则</h3><p>上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。</p>\n<p>JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：</p>\n<ol>\n<li><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p>\n</li>\n<li><p>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</p>\n</li>\n</ol>\n<p>上面的1）是JMM对程序员的承诺。</p>\n<p>从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。<strong>注意，这只是Java内存模型向程序员做出的保证</strong></p>\n<p>上面的2）是JMM对编译器和处理器重排序的约束原则。</p>\n<p>正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。</p>\n<h3 id=\"具体规则\"><a href=\"#具体规则\" class=\"headerlink\" title=\"具体规则\"></a>具体规则</h3><ol>\n<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>\n<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>\n<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>\n<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>\n<li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>\n<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>\n<li>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>\n<li>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>\n</ol>\n<h3 id=\"JMM对三个特性保证\"><a href=\"#JMM对三个特性保证\" class=\"headerlink\" title=\"JMM对三个特性保证\"></a>JMM对三个特性保证</h3><h4 id=\"JMM与原子性\"><a href=\"#JMM与原子性\" class=\"headerlink\" title=\"JMM与原子性\"></a>JMM与原子性</h4><ul>\n<li>X=10 写 原子性  如果是私有数据具有原子性，如果是共享数据没原子性（读写） </li>\n<li>Y=x 没有原子性<ul>\n<li>把数据X读到工作空间（原子性）</li>\n<li>把X的值写到Y（原子性）</li>\n</ul>\n</li>\n<li>I++ 没有原子性<ul>\n<li>读i到工作空间</li>\n<li>+1；</li>\n<li>刷新结果到内存</li>\n</ul>\n</li>\n<li>Z=z+1 没有原子性<ul>\n<li>读z到工作空间</li>\n<li>+1；</li>\n<li>刷新结果到内存</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>多个原子性的操作合并到一起没有原子性</p>\n</blockquote>\n<p>保证方式：</p>\n<ol>\n<li>Synchronized</li>\n<li>JUC  Lock的lock</li>\n</ol>\n<h4 id=\"JMM与可见性\"><a href=\"#JMM与可见性\" class=\"headerlink\" title=\"JMM与可见性\"></a>JMM与可见性</h4><ol>\n<li>Volatile:在JMM模型上实现MESI协议</li>\n<li>Synchronized:加锁</li>\n<li>JUC  JUC  Lock的lock</li>\n</ol>\n<h4 id=\"JMM与有序性\"><a href=\"#JMM与有序性\" class=\"headerlink\" title=\"JMM与有序性\"></a>JMM与有序性</h4><ol>\n<li>Volatile</li>\n<li>Synchronized</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]}]}},"cover":"https://s3.charlesnote.com/cover/default_bg2.jpg","excerpt":"","more":"<h2 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h2><h3 id=\"程序\"><a href=\"#程序\" class=\"headerlink\" title=\"程序\"></a>程序</h3><p>由代码编译成功得到的二进制文件。在Windows中就是.exe文件。程序只占用磁盘空间。 这是一个静态的概念。</p>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><p>运行起来的程序。进程需要占用系统资源（内存，CPU）。<strong>进程是最小的系统资源分配单位</strong>，只是给线程提供执行环境。 这是一个动态的概念</p>\n<blockquote>\n<p> 由于一个进程产生一个进程地址空间，且进程地址空间相互独立，一个进程死亡，其他进程不会受到影响。</p>\n</blockquote>\n<h4 id=\"进程的状态变更\"><a href=\"#进程的状态变更\" class=\"headerlink\" title=\"进程的状态变更\"></a>进程的状态变更</h4><p><img src=\"https://s3.charlesnote.com/bak/FvhDrmv6baLquaN1f68BIUT1RNN8\"></p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><p>LWP（light weight process）轻量级进程。<strong>线程是最小的执行单位</strong>。CPU分配时间轮片的对象。</p>\n<p>产生原因：提高争夺到CPU的概率。</p>\n<p><img src=\"https://s3.charlesnote.com/bak/FqYjg9vQLvrYBse44rBOINfmRcVn\"></p>\n<h3 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h3><p>coroutine，也叫轻量级线程。 与传统的系统级线程和进程相比，携程最大的优势在于“轻量级”，可以轻松创建上万个而不会导致系统资源衰歇。而线程和进程通常很难超过1万个。一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。</p>\n<p>产生原因：提高程序执行的效率。（利用闲暇时间执行其他任务）</p>\n<blockquote>\n<p>go协程：叫goroutine。在进程中创建。它比线程更小，十几个goroutine可能体现在底层就是五六个线程，go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需要极少的栈内存（大概4~5kb），当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用，更高效，更轻便。一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松的让成百上千个goroutine进行资源竞争。</p>\n</blockquote>\n<h2 id=\"二、Java线程与系统线程的关系\"><a href=\"#二、Java线程与系统线程的关系\" class=\"headerlink\" title=\"二、Java线程与系统线程的关系\"></a>二、Java线程与系统线程的关系</h2><h3 id=\"操作系统线程状态\"><a href=\"#操作系统线程状态\" class=\"headerlink\" title=\"操作系统线程状态\"></a>操作系统线程状态</h3><p>操作系统中的线程除去new和terminated状态，一个线程真实存在的状态，只有：</p>\n<ul>\n<li>ready：表示线程已经被创建，正在等待系统调度分配CPU使用权。</li>\n<li>running：表示线程获得了CPU使用权，正在进行运算</li>\n<li>waiting：表示线程等待（或者说挂起），让出CPU资源给其他线程使用</li>\n</ul>\n<blockquote>\n<p>为什么除去new和terminated状态？<br>是因为这两种状态实际上并不存在于线程运行中，所以也没什么实际讨论的意义</p>\n</blockquote>\n<h3 id=\"Java中的线程状态\"><a href=\"#Java中的线程状态\" class=\"headerlink\" title=\"Java中的线程状态\"></a>Java中的线程状态</h3><p>无论是<code>Timed Waiting</code> ，<code>Waiting</code>还是<code>Blocked</code>，对应的都是操作系统线程的<code>waiting(等待)</code>状态。而<code>Runnable</code>状态，则对应了操作系统中的<code>ready</code>和<code>running</code>状态。</p>\n<p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下：</p>\n<ul>\n<li><p>新建（New）：创建后尚未启动的线程处于这种状态。</p>\n</li>\n<li><p>运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</p>\n</li>\n<li><p>阻塞（Blocked）：线程阻塞于锁</p>\n</li>\n<li><p>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其它线程显示地唤醒。以下方法会让线程陷入无限期的等待状态：</p>\n<ul>\n<li>没有设置Timeout参数的Object.wait()方法</li>\n<li>没有设置Timeout参数的Thread.join()方法</li>\n<li>LockSupport.park()方法</li>\n</ul>\n</li>\n<li><p>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其它线程显示地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p>\n<ul>\n<li>Thread.sleep()方法</li>\n<li>设置了Timeout参数的Object.wait()方法</li>\n<li>设置了Timeout参数的Thread.join()方法</li>\n<li>LockSupport.parkNanos()方法</li>\n<li>LockSupport.parkUntil()方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>而对不同的操作系统，由于本身设计思路不一样，对于线程的设计也存在种种差异，所以JVM在设计上，就已经声明：</p>\n<blockquote>\n<p> <strong>JVM虚拟机中的线程状态，不反应任何操作系统线程状态</strong></p>\n</blockquote>\n<h2 id=\"三、JVM的内存结构\"><a href=\"#三、JVM的内存结构\" class=\"headerlink\" title=\"三、JVM的内存结构\"></a>三、JVM的内存结构</h2><p><img src=\"https://s3.charlesnote.com/bak/Fief69LdYrWe_TRdkcvcqcIPQxsZ\"></p>\n<p>按照JVM规范，JVM内存分为以下五个区域</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是一块很小的内存空间，它是<strong>线程私有</strong>的，可以认作为当前线程的行号指示器。</p>\n<p><strong>为什么需要程序计数器</strong></p>\n<blockquote>\n<p>我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。</p>\n<p>注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。<strong>这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域</strong>。</p>\n</blockquote>\n<h3 id=\"Java栈（虚拟机栈）\"><a href=\"#Java栈（虚拟机栈）\" class=\"headerlink\" title=\"Java栈（虚拟机栈）\"></a>Java栈（虚拟机栈）</h3><p>同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，<strong>栈描述的是Java方法执行的内存模型</strong>。</p>\n<p><strong>每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。【栈先进后出】</strong></p>\n<h5 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h5><blockquote>\n<p>栈帧: 是用来存储数据和部分过程结果的数据结构。<br>栈帧的位置:  内存 -&gt; 运行时数据区 -&gt; 某个线程对应的虚拟机栈 -&gt; here[在这里]<br>栈帧大小确定时间: 编译期确定，不受运行期数据影响。</p>\n</blockquote>\n<p><strong>平时说的栈一般指局部变量表部分。</strong></p>\n<p>局部变量表:一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型。它的最小的局部变量表空间单位为Slot，虚拟机没有指明Slot的大小，但在jvm中，long和double类型数据明确规定为64位，这两个类型占2个Slot，其它基本类型固定占用1个Slot。</p>\n<p>reference类型:与基本类型不同的是它不等同本身，即使是String，内部也是char数组组成，它可能是指向一个对象起始位置指针，也可能指向一个代表对象的句柄或其他与该对象有关的位置。</p>\n<p>returnAddress类型:指向一条字节码指令的地址【深入理解Java虚拟机】<a href=\"https://links.jianshu.com/go?to=https://www.zhihu.com/question/29056872\">怎么理解returnAddress</a></p>\n<p><img src=\"https://s3.charlesnote.com/bak/Ft8GzLecmWmAd8X5Em3GkOmIyZKZ\"></p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>对于大多数应用来说，<strong>堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制</strong>。</p>\n<p>java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。</p>\n<blockquote>\n<p>即时编译器:可以把Java的字节码，包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序)</p>\n<p>逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。</p>\n</blockquote>\n<p>注意:它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代，再细致点还有Eden(伊甸园)空间之类的不做深究。</p>\n<p>根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。</p>\n<p>当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。</p>\n<p>用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。</p>\n<blockquote>\n<p>运行时常量池</p>\n<p>是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。</p>\n</blockquote>\n<p>在老版jdk，方法区的实现是永久代【因为没有强制要求方法区必须实现垃圾回收，HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。JDK8之后改为了metadata space（元数据空间）】</p>\n<h2 id=\"四、Java内存模型（JMM）\"><a href=\"#四、Java内存模型（JMM）\" class=\"headerlink\" title=\"四、Java内存模型（JMM）\"></a>四、Java内存模型（JMM）</h2><p><img src=\"https://s3.charlesnote.com/bak/FvZP0DodmgC-YLN-izgTp3PwDmJQ\"></p>\n<ol>\n<li><p>主内存：共享的信息</p>\n</li>\n<li><p>工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中</p>\n</li>\n<li><p>工作方式：</p>\n<ol>\n<li>线程修改私有数据，直接在工作空间修改</li>\n<li>线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"五、硬件结构\"><a href=\"#五、硬件结构\" class=\"headerlink\" title=\"五、硬件结构\"></a>五、硬件结构</h2><p><img src=\"https://s3.charlesnote.com/bak/Fr9Qc5zY63C7x94rXJKTTmDOfbhy\"></p>\n<ul>\n<li>CPU缓存的一致性问题：并发处理的不同步</li>\n<li>解决方案：<ul>\n<li>总线加锁（ 降低CPU的吞吐量）</li>\n<li>缓存上的一致性协议（MESI）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Cache的写方式\"><a href=\"#Cache的写方式\" class=\"headerlink\" title=\"Cache的写方式\"></a>Cache的写方式</h3><ol>\n<li>write through（写通）：每次CPU修改了cache中的内容，立即更新到内存，也就意味着每次CPU写共享数据，都会导致总线事务，因此这种方式常常会引起总线事务的竞争，高一致性，但是效率非常低；</li>\n<li>write back（写回）：每次CPU修改了cache中的数据，不会立即更新到内存，而是等到cache line在某一个必须或合适的时机才会更新到内存中；</li>\n</ol>\n<blockquote>\n<p>无论是写通还是写回，在多线程环境下都需要处理缓存cache一致性问题。为了保证缓存一致性，处理器又提供了写失效（write invalidate）和写更新（write update）两个操作来保证cache一致性。</p>\n</blockquote>\n<ol start=\"3\">\n<li><p>写失效：当一个CPU修改了数据，如果其他CPU有该数据，则通知其为无效；</p>\n</li>\n<li><p>写更新：当一个CPU修改了数据，如果其他CPU有该数据，则通知其跟新数据；</p>\n</li>\n</ol>\n<blockquote>\n<p> 写更新会导致大量的更新操作，因此在MESI协议中，采取的是写失效（即MESI中的I：ivalid，如果采用的是写更新，那么就不是MESI协议了，而是MESU协议）。</p>\n</blockquote>\n<h3 id=\"缓存一致性协议（MESI）\"><a href=\"#缓存一致性协议（MESI）\" class=\"headerlink\" title=\"缓存一致性协议（MESI）\"></a>缓存一致性协议（MESI）</h3><p>简单理解：当CPU在CACHE中操作数据时，如果该数据是共享变量，数据在CACHE读到寄存器中，进行新修改，并更新内存数据，CACHE LINE置无效，其他的CPU就从内存中读数据</p>\n<p>缓存一致性：在多核CPU中，内存中的数据会在多个核心中存在数据副本，某一个核心发生修改操作，就产生了数据不一致的问题。而一致性协议正是用于保证多个CPU cache之间缓存共享数据的一致。</p>\n<blockquote>\n<p>MESI，则是缓存一致性协议中的一个，到底怎么实现，还是得看具体的处理器指令集。</p>\n</blockquote>\n<h4 id=\"Cache的状态\"><a href=\"#Cache的状态\" class=\"headerlink\" title=\"Cache的状态\"></a>Cache的状态</h4><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I: Invalid（无效），该CPU中该Cache字段失效</span><br><span class=\"line\">S: Shared（共享），多个CPU的Cache均共享该数据</span><br><span class=\"line\">E: Exclusive（独占），数据只在该CPU独有，其它CPU变为Invalid状态</span><br><span class=\"line\">M: Modified（已修改），与E状态类似，但是数据已经被修改，在其变为Invalid状态时，需要先将数据回写到内存 </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"状态机\"><a href=\"#状态机\" class=\"headerlink\" title=\"状态机\"></a>状态机</h4><p><img src=\"https://s3.charlesnote.com/bak/FkWs6x0Gqchk3l0u0fC7PR931xLU\"></p>\n<h2 id=\"六、并发编程的三个重要特性\"><a href=\"#六、并发编程的三个重要特性\" class=\"headerlink\" title=\"六、并发编程的三个重要特性\"></a>六、并发编程的三个重要特性</h2><ol>\n<li>原子性：不可分割 （x=1）</li>\n<li>可见性：线程只能操作自己工作空间中的数据</li>\n<li>有序性：程序中的顺序不一定就是执行的顺序<ol>\n<li>编译重排序</li>\n<li>指令重排序（处理器重排序）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"as-if-serial规则\"><a href=\"#as-if-serial规则\" class=\"headerlink\" title=\"as-if-serial规则\"></a>as-if-serial规则</h3><p>as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p>\n<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> pi  = <span class=\"number\">3.14</span>;    <span class=\"comment\">//A</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> r   = <span class=\"number\">1.0</span>;     <span class=\"comment\">//B</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> area = pi * r * r; <span class=\"comment\">//C</span></span><br></pre></td></tr></table></figure>\n\n\n<p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同让编写单线程程序的程序员产生了一个幻觉：单线程程序是按程序的顺序来执行的<strong>。</strong>as-if-serial语义使程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>\n<h3 id=\"happens-before规则\"><a href=\"#happens-before规则\" class=\"headerlink\" title=\"happens-before规则\"></a>happens-before规则</h3><p>上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。</p>\n<p>JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：</p>\n<ol>\n<li><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p>\n</li>\n<li><p>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</p>\n</li>\n</ol>\n<p>上面的1）是JMM对程序员的承诺。</p>\n<p>从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。<strong>注意，这只是Java内存模型向程序员做出的保证</strong></p>\n<p>上面的2）是JMM对编译器和处理器重排序的约束原则。</p>\n<p>正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。</p>\n<h3 id=\"具体规则\"><a href=\"#具体规则\" class=\"headerlink\" title=\"具体规则\"></a>具体规则</h3><ol>\n<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>\n<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>\n<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>\n<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>\n<li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>\n<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>\n<li>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>\n<li>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>\n</ol>\n<h3 id=\"JMM对三个特性保证\"><a href=\"#JMM对三个特性保证\" class=\"headerlink\" title=\"JMM对三个特性保证\"></a>JMM对三个特性保证</h3><h4 id=\"JMM与原子性\"><a href=\"#JMM与原子性\" class=\"headerlink\" title=\"JMM与原子性\"></a>JMM与原子性</h4><ul>\n<li>X=10 写 原子性  如果是私有数据具有原子性，如果是共享数据没原子性（读写） </li>\n<li>Y=x 没有原子性<ul>\n<li>把数据X读到工作空间（原子性）</li>\n<li>把X的值写到Y（原子性）</li>\n</ul>\n</li>\n<li>I++ 没有原子性<ul>\n<li>读i到工作空间</li>\n<li>+1；</li>\n<li>刷新结果到内存</li>\n</ul>\n</li>\n<li>Z=z+1 没有原子性<ul>\n<li>读z到工作空间</li>\n<li>+1；</li>\n<li>刷新结果到内存</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>多个原子性的操作合并到一起没有原子性</p>\n</blockquote>\n<p>保证方式：</p>\n<ol>\n<li>Synchronized</li>\n<li>JUC  Lock的lock</li>\n</ol>\n<h4 id=\"JMM与可见性\"><a href=\"#JMM与可见性\" class=\"headerlink\" title=\"JMM与可见性\"></a>JMM与可见性</h4><ol>\n<li>Volatile:在JMM模型上实现MESI协议</li>\n<li>Synchronized:加锁</li>\n<li>JUC  JUC  Lock的lock</li>\n</ol>\n<h4 id=\"JMM与有序性\"><a href=\"#JMM与有序性\" class=\"headerlink\" title=\"JMM与有序性\"></a>JMM与有序性</h4><ol>\n<li>Volatile</li>\n<li>Synchronized</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckyn6c72k0001gtno1ity3u0y","category_id":"ckyn6c72p0003gtnofcta0gns","_id":"ckyn6c72s0007gtno9pefdgem"},{"post_id":"ckyn6c73e000cgtno86cr7nmw","category_id":"ckyn6c72p0003gtnofcta0gns","_id":"ckyn6c73f000egtnohko962s4"}],"PostTag":[{"post_id":"ckyn6c72k0001gtno1ity3u0y","tag_id":"ckyn6c72q0004gtno6e7eghtb","_id":"ckyn6c72t0009gtno6dkqf5il"},{"post_id":"ckyn6c72k0001gtno1ity3u0y","tag_id":"ckyn6c72s0006gtnobnq88zba","_id":"ckyn6c72t000agtnodbsu9mmi"},{"post_id":"ckyn6c72k0001gtno1ity3u0y","tag_id":"ckyn6c72s0008gtno0l1j0idk","_id":"ckyn6c72t000bgtno9nu58m8i"},{"post_id":"ckyn6c73e000cgtno86cr7nmw","tag_id":"ckyn6c73f000dgtnoc5czfqx5","_id":"ckyn6c73g000ggtno30uw32qv"},{"post_id":"ckyn6c73e000cgtno86cr7nmw","tag_id":"ckyn6c73g000fgtno96vd1tqb","_id":"ckyn6c73g000hgtno0pieewu5"}],"Tag":[{"name":"spring","_id":"ckyn6c72q0004gtno6e7eghtb"},{"name":"ioc","_id":"ckyn6c72s0006gtnobnq88zba"},{"name":"aop","_id":"ckyn6c72s0008gtno0l1j0idk"},{"name":"JVM","_id":"ckyn6c73f000dgtnoc5czfqx5"},{"name":"内存模型","_id":"ckyn6c73g000fgtno96vd1tqb"}]}}